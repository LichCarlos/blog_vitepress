# 前端面试题
## http
### http版本：1.1、2.0

飞书：2.0  hao123：1.1

如何查看版本：
```js
//返回在控制台输出的npnNegotiatedProtocol 可以看到返回的版本
window.chrome.loadTimes()

```

### http的发展过程
0.9 第一版本已过时，只允许发get请求

1.0新增post请求，允许发送cookie。

1.1新增keep-alive长连接，允许发送大文件，减少内存开销。

2.0头部支持二进制、多路复用。

### http1.1的特点
默认使用长连接

支持pipeline。

 1.长连接：引入了tcp链接复用，一个tcp默认不关闭，可以重复使用，减少开销。
 2.并发连接（谷歌是6个）：对一个域名请求允许分配多个长连接（缓解了对头阻塞的问题）
 3.引入管道机制，一个tcp链接可以同时发送多个请求，可以并行处理（但相应顺序必须一致）。
 4.新增PUT\DELETE\PATCH\OPTIONS\TRACE等方法，用于更新资源。
 5.新增了缓存字段
 6.引入了range字段，用于分片下载。支持断点续传。
 7.允许响应数据分块（chunked）利于传输文件。
 8.强制要求host投，让互联网主机托管成为可能。

### http2.0的特点
 1.支持二进制
 2.多路复用（废弃了管道、避免了队头堵塞（收到的数据不需要和发出的顺序一致）
 3.头部压缩
 4.服务器主动推送
 5.数据流：服务器以stream的形式返回数据，客户端可以主动关闭流。

### 什么是长连接 keep-alive
开启后，只需要一次握手，多次收发。

### pipeline和长连接的区别、和多路复用的区别
pipeline将串行改为并行，不必等待请求响应就可以发下一个请求（但响应结果必须按顺序返回）

### http3.0特点
原因：多路复用解决的是http层面的对头阻塞，而不是tcp协议层面的。（当流的数据包丢失时，tcp需要重新发包，只有全部返回时http才会处理这被称作tcp的队头阻塞）

 1.基于udp协议，的quic协议不需要建立tcp连接，减少开销
 2.udp不需要三次握手，缩短tls建立时间、减少了延时）
 3.彻底解决了对头阻塞
 4.迁移平滑（4g到wifi
 5.实现拥塞算法
 6.数据加密

### https加密过程
对称加密
非对称加密

### http状态码
1xx：代表正在处理请求
2xx：成功响应请求
3xx：302重定向、304缓存
4xx：客户端错误 401未登录 403无权限、404没有找到资源
500：服务端错误 
## 网络

### 网络是如何分层的（OSI七层模型和TCP/IP四层模型）

常用TCP/IP四层（加物理层5层）
物理层
 该层负责比特流在节点间的传输，即负责物理传输。通俗来讲就是把计算机连接起来的物理手段。
代表作用：传输 0 1 0 1信号
代表设备： 网线、光纤
数据链路层
 该层控制网络层与物理层之间的通信，其主要功能是如何在不可靠的物理线路上进行数据的可靠传递。为了保证传输，从网络层接收到的数据被分割成特定的可被物理层传输的帧。
帧就是对0 1 数据的封装。
一帧是64-1518字节。
代表作用： Mac地址确认、Arp广播
代表设备： 交换机
网络层
 该层决定如何将数据从发送方路由到接收方。网络层通过综合考虑发送优先权、网络拥塞程度、服务质量以及可选路由的花费来决定从一个网络中的节点 A 到另一个网络中节点 B 的最佳路径。
代表作用：分配IP地址
代表设备： 家用路由器
传输层
 该层为两台主机上的应用程序提供端到端的通信。相比之下，网络层的功能是建立主机到主机的通
 信。
代表作用：连接端到端、例如TCP、UDP
代表设备： 操作系统内核
应用层
 应用程序收到传输层的数据后，接下来就要进行解读。解读必须事先规定好格式，而应用层就是规定应用程序的数据格式的。它的主要协议有HTTP、FTP、Telnet、SMTP、POP3等。

### TCP/UDP的区别
 1.TCP：面向连接的、UDP无连接的。  TCP：可靠、UDP不可靠
 2.UDP更好实时性。工作效率更高。   场景：udp：网络中直播、游戏 tcp：网页
 3.TCP：面向字节流（把数据看成无结构的字节流）、UDP面向报文段（报文不可分割）
 4.tcp一对一udp支持一对一一对多多对多
 5.TCP：首部开销20字节udp首部开销8字节
 6.udp传输较小的网络应用：dns、snmp


### TCP的三次握手
client：发送syn包，发送一个随机数，标识这个包，标识这个包是请求连接。SYN seq=x
server：收到后，发送syn+ack包，ack=x+1，seq=y
client：收到后，发送ack包，ack=y+1,seq=x+1

### TCP的4次挥手

主动断开的一侧为A，被动断开的一侧为B。
第一个消息：A发FIN
第二个消息：B回复ACK
第三个消息：B发出FIN
此时此刻：B单方面认为自己与A达成了共识，即双方都同意关闭连接。
此时，B能释放这个TCP连接占用的内存资源吗？不能，B一定要确保A收到自己的ACK、FIN。
所以B需要静静地等待A的第四个消息的到来：
第四个消息：A发出ACK，用于确认收到B的FIN
当B接收到此消息，即认为双方达成了同步：双方都知道连接可以释放了，此时B可以安全地释放此TCP连接所占用的内存资源、端口号。
所以被动关闭的B无需任何wait time，直接释放资源。
但，A（客户端）并不知道B（服务器）是否接到自己的ACK，A是这么想的：
1）如果B没有收到自己的ACK，会超时重传FiN
那么A再次接到重传的FIN，会再次发送ACK
2）如果B收到自己的ACK，也不会再发任何消息，包括ACK
无论是1还是2，A都需要等待，要取这两种情况等待时间的最大值，以应对最坏的情况发生，这个最坏情况是：
去向ACK消息最大存活时间（MSL） + 来向FIN消息的最大存活时间(MSL)。
这恰恰就是2MSL( Maximum Segment Life)。
等待2MSL时间，A就可以放心地释放TCP占用的资源、端口号，此时可以使用该端口号连接任何服务器。
1MSL实际应用中常用的是30秒，1分钟和2分钟等。

### TCP滑动窗口

滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。

TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区（内存占用）可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。

客户端和服务器达成一致，我到底要发送多大的数据包过去给对方。
TCP也维持了一个滑动窗口，它解决是个端到端的问题，并且动态变化。
### TCP的拥塞控制有什么作用

在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。

为了进行拥塞控制，TCP 发送方要维持一个 拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。
### 滑动窗口和拥塞控制的区别？
滑动窗口解决我跟你自己本身的问题。
拥塞控制解决，我去你那里的路况拥堵问题。
滑动窗口：
你邀请我，去你家玩耍。
我家里人多，准了8台车。
你家的院子只能停4台车。
你能否分两批来玩？
这个过程就叫滑动窗口。

拥塞窗口：
你邀请我，去你家玩耍。
我家里人多，准了8台车。
你家的院子也能停8台车。
但是今天周末，超级堵车。
我的车只能一台一台出发，比如每隔五分钟出发一辆。
我同时出发8台车呢？
会把路堵死，更慢。


发送方让自己的发送窗口取拥塞窗口和滑动窗口中较小的一个。

## 浏览器



## JavaScript

### 自定义实现unshift
```javascript
Array.prototype.myunshift = function() {
  const len = arguments.length;
  for (let i = len -1 ; i >0,i--){
    const element = arguments[i];
    this.splice(i,0,element)
  }
  return this.length;
}

let arr = [1,2,3]
console.log(arr.myunshift(3,4,5))

```

### 数组去重
