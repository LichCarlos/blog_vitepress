# npm install 原理

## 在执行 `npm install` 的时候发生了什么？

当运行 `npm install` 命令时，npm 会根据项目根目录下的 `package.json` 文件中的依赖信息来安装所需的包及其依赖。整个过程可以分为以下几个关键步骤：

### 1. 解析 `package.json`

- **读取依赖声明**：npm 从 `package.json` 中读取 `dependencies` 和 `devDependencies` 字段，以确定需要安装哪些包以及它们的版本范围。
- **解析版本范围**：对于每个依赖项，npm 解析其版本范围（如 `^1.2.3` 或 `~4.5.6`），以了解哪些版本是可接受的。

### 2. 构建依赖树

- **构建完整的依赖关系图**：npm 递归地构建一个依赖关系图，包含所有直接依赖及其间接依赖。这个图可能非常复杂，因为每个包都可能有自己的依赖。
- **解决版本冲突**：如果多个依赖项要求同一包的不同版本，npm 会尝试找到一个满足所有需求的公共版本。如果找不到这样的版本，它可能会安装多个版本以确保兼容性。

### 3. 安装依赖

- **扁平化安装**：默认情况下，npm 使用“扁平化”安装策略，这意味着尽可能将所有依赖直接放置在 `node_modules` 目录下，而不是创建深层嵌套的结构。这种做法减少了模块查找的时间，并且有助于避免重复安装相同的包。
- **排序规则**：在 `node_modules` 中，`.bin` 文件夹总是位于最前面，接着是带有 `@` 符号的作用域包（scoped packages），然后按照字母顺序排列其他包。
- **广度优先遍历**：npm 使用广度优先算法来遍历依赖树。这意味着它首先处理项目根目录下的直接依赖，然后再逐层处理每个依赖包的子依赖，直到所有的依赖都被处理完毕。

### 4. 检查与验证

- **版本匹配检查**：在安装过程中，npm 会检查已安装的包是否符合 `package.json` 中指定的版本要求。如果某个包的版本不符合预期，npm 会尝试安装适合的版本。
- **peerDependencies 处理**：对于 `peerDependencies`，npm 会确保这些依赖在项目的根 `node_modules` 中存在适当的版本，否则会发出警告或错误。

### 5. 创建 `package-lock.json`

- **锁定依赖版本**：为了确保不同环境之间的依赖一致性，npm 会生成或更新 `package-lock.json` 文件。该文件精确记录了每个依赖的确切版本，使得在任何地方运行 `npm install` 都能重现完全相同的依赖环境。

### 6. 完成安装

- **完成消息**：一旦所有依赖都被成功安装并且没有任何冲突，npm 将输出一条完成消息，告知用户安装已经结束。
- **清理临时文件**：最后，npm 可能会清理一些临时文件或缓存，以保持系统的整洁。

## 什么是扁平化
扁平化（Flattening）在 npm 的上下文中指的是依赖管理的一种策略，旨在减少 node_modules 目录中模块的嵌套层级。具体来说，扁平化安装意味着尽可能地将所有依赖直接放置在顶层的 node_modules 文件夹中。
### 示例
假设你有一个项目依赖于两个库 A 和 B，而这两个库又都依赖于 C 的不同版本。在传统的非扁平化安装中，可能会出现如下结构：

```
node_modules/
├── A/
│   └── node_modules/
│       └── C@1.0.0
└── B/
    └── node_modules/
        └── C@2.0.0
```
而在扁平化安装下，如果 C 的两个版本可以兼容，那么结果可能是这样的：

```
node_modules/
├── A/
├── B/
└── C@2.0.0
```
或者，如果有冲突且无法协调版本，可能会安装两个版本：

```
node_modules/
├── A/
├── B/
├── C@1.0.0
└── C@2.0.0
```

## 实行扁平化策略原因
在 npm 的扁平化安装策略中，node_modules 目录结构被设计为尽可能减少嵌套层级，并且尽量将所有依赖直接放置在顶层 node_modules 文件夹中。这种策略有几个关键原因：

### 1. 模块解析机制
Node.js 使用一种特殊的模块解析算法来查找和加载模块。当一个模块尝试引入另一个模块时，Node.js 会从当前文件所在的目录开始向上逐层搜索 node_modules 文件夹，直到找到所需的模块或到达根目录。

例如，如果模块 A 和 B 都依赖于模块 C，而 C 被安装在顶层 node_modules 中，那么无论 A 或 B 在哪里，它们都能正确地解析到顶层的 C。因此，没有必要在每个依赖包的子 node_modules 文件夹中重复安装 C。

### 2. 版本协调
npm 尝试协调不同依赖之间的版本冲突。如果模块 A 和 B 都可以使用同一个版本的 C，npm 将只安装一个版本的 C 到顶层 node_modules 中。这不仅减少了冗余，还确保了整个项目中只有一个版本的 C 被使用，从而避免潜在的兼容性问题。

### 3. 路径长度限制
尤其在 Windows 系统上，文件路径长度是有限制的（通常为 260 个字符）。深层嵌套的 node_modules 结构可能会导致路径过长的问题。通过扁平化安装，npm 可以有效避免这种情况的发生。

### 4. 性能优化
扁平化的 node_modules 结构减少了 Node.js 解析模块时需要遍历的目录层数，从而提高了模块解析的速度。此外，它也使得 node_modules 更易于管理和理解。

## 版本冲突处理
然而，当确实存在无法协调的版本冲突时，npm 会在顶层 node_modules 中安装多个版本的模块。例如，如果 A 依赖于 C@1.0.0 而 B 依赖于 C@2.0.0 并且这两个版本不兼容，则 npm 会分别安装这两个版本到顶层 node_modules 中：

```
node_modules/
├── A/
├── B/
├── C@1.0.0
└── C@2.0.0
```

在这种情况下，npm 还会在各自的 node_modules 文件夹中创建符号链接（symlinks）指向正确的 C 版本，以便 A 和 B 分别使用它们所需的具体版本：
```
node_modules/
├── A/
│   └── node_modules/
│       └── C -> ../../C@1.0.0
├── B/
│   └── node_modules/
│       └── C -> ../../C@2.0.0
├── C@1.0.0
└── C@2.0.0
```
这样做既保持了扁平化的优势，又确保了各个模块能够正确访问其所需的特定版本的依赖项。